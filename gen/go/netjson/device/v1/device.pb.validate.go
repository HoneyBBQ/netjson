// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: netjson/device/v1/device.proto

package devicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DeviceConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeviceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeviceConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeviceConfigMultiError, or
// nil if none found.
func (m *DeviceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeviceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	_DeviceConfig_DnsServers_Unique := make(map[string]struct{}, len(m.GetDnsServers()))

	for idx, item := range m.GetDnsServers() {
		_, _ = idx, item

		if _, exists := _DeviceConfig_DnsServers_Unique[item]; exists {
			err := DeviceConfigValidationError{
				field:  fmt.Sprintf("DnsServers[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_DeviceConfig_DnsServers_Unique[item] = struct{}{}
		}

		// no validation rules for DnsServers[idx]
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceConfigValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInterfaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Interfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Interfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceConfigValidationError{
					field:  fmt.Sprintf("Interfaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRadios() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Radios[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  fmt.Sprintf("Radios[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceConfigValidationError{
					field:  fmt.Sprintf("Radios[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.General != nil {

		if all {
			switch v := interface{}(m.GetGeneral()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  "General",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeviceConfigValidationError{
						field:  "General",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGeneral()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeviceConfigValidationError{
					field:  "General",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeviceConfigMultiError(errors)
	}

	return nil
}

// DeviceConfigMultiError is an error wrapping multiple validation errors
// returned by DeviceConfig.ValidateAll() if the designated constraints aren't met.
type DeviceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeviceConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeviceConfigMultiError) AllErrors() []error { return m }

// DeviceConfigValidationError is the validation error returned by
// DeviceConfig.Validate if the designated constraints aren't met.
type DeviceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeviceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeviceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeviceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeviceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeviceConfigValidationError) ErrorName() string { return "DeviceConfigValidationError" }

// Error satisfies the builtin error interface
func (e DeviceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeviceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeviceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeviceConfigValidationError{}

// Validate checks the field values on General with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *General) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on General with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GeneralMultiError, or nil if none found.
func (m *General) ValidateAll() error {
	return m.validate(true)
}

func (m *General) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Hostname != nil {

		if utf8.RuneCountInString(m.GetHostname()) > 63 {
			err := GeneralValidationError{
				field:  "Hostname",
				reason: "value length must be at most 63 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Timezone != nil {
		// no validation rules for Timezone
	}

	if m.Maintainer != nil {
		// no validation rules for Maintainer
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.UlaPrefix != nil {
		// no validation rules for UlaPrefix
	}

	if m.Zonename != nil {
		// no validation rules for Zonename
	}

	if m.Notes != nil {
		// no validation rules for Notes
	}

	if m.BufferSizeKb != nil {
		// no validation rules for BufferSizeKb
	}

	if m.ConsoleLogLevel != nil {
		// no validation rules for ConsoleLogLevel
	}

	if m.CronLogLevel != nil {
		// no validation rules for CronLogLevel
	}

	if m.KernelConsoleLogLevel != nil {
		// no validation rules for KernelConsoleLogLevel
	}

	if m.LogBufferSizeKb != nil {
		// no validation rules for LogBufferSizeKb
	}

	if m.LogFile != nil {
		// no validation rules for LogFile
	}

	if m.LogHostname != nil {
		// no validation rules for LogHostname
	}

	if m.LogIp != nil {
		// no validation rules for LogIp
	}

	if m.LogPort != nil {

		if m.GetLogPort() != 0 {

			if m.GetLogPort() > 65535 {
				err := GeneralValidationError{
					field:  "LogPort",
					reason: "value must be less than or equal to 65535",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.LogPrefix != nil {
		// no validation rules for LogPrefix
	}

	if m.LogProtocol != nil {
		// no validation rules for LogProtocol
	}

	if m.LogRemote != nil {
		// no validation rules for LogRemote
	}

	if m.LogSizeKb != nil {
		// no validation rules for LogSizeKb
	}

	if m.LogTrailerNull != nil {
		// no validation rules for LogTrailerNull
	}

	if m.LogType != nil {
		// no validation rules for LogType
	}

	if m.TtyLoginRequired != nil {
		// no validation rules for TtyLoginRequired
	}

	if m.UrandomSeedEnabled != nil {
		// no validation rules for UrandomSeedEnabled
	}

	if m.ZramCompression != nil {
		// no validation rules for ZramCompression
	}

	if m.ZramSizeMb != nil {
		// no validation rules for ZramSizeMb
	}

	if m.GlobalsId != nil {
		// no validation rules for GlobalsId
	}

	if len(errors) > 0 {
		return GeneralMultiError(errors)
	}

	return nil
}

// GeneralMultiError is an error wrapping multiple validation errors returned
// by General.ValidateAll() if the designated constraints aren't met.
type GeneralMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeneralMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeneralMultiError) AllErrors() []error { return m }

// GeneralValidationError is the validation error returned by General.Validate
// if the designated constraints aren't met.
type GeneralValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeneralValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeneralValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeneralValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeneralValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeneralValidationError) ErrorName() string { return "GeneralValidationError" }

// Error satisfies the builtin error interface
func (e GeneralValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeneral.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeneralValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeneralValidationError{}

// Validate checks the field values on Interface with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Interface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Interface with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InterfaceMultiError, or nil
// if none found.
func (m *Interface) ValidateAll() error {
	return m.validate(true)
}

func (m *Interface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 15 {
		err := InterfaceValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 15 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Interface_Name_Pattern.MatchString(m.GetName()) {
		err := InterfaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[^\\\\s]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := InterfaceValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVlanFiltering() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("VlanFiltering[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  fmt.Sprintf("VlanFiltering[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  fmt.Sprintf("VlanFiltering[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Mtu != nil {

		if m.GetMtu() < 68 {
			err := InterfaceValidationError{
				field:  "Mtu",
				reason: "value must be greater than or equal to 68",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if m.Mac != nil {

		if m.GetMac() != "" {

			if !_Interface_Mac_Pattern.MatchString(m.GetMac()) {
				err := InterfaceValidationError{
					field:  "Mac",
					reason: "value does not match regex pattern \"^(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})|)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Autostart != nil {
		// no validation rules for Autostart
	}

	if m.Wireless != nil {

		if all {
			switch v := interface{}(m.GetWireless()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Wireless",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Wireless",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWireless()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Wireless",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Txqueuelen != nil {
		// no validation rules for Txqueuelen
	}

	if m.IgmpSnooping != nil {
		// no validation rules for IgmpSnooping
	}

	if m.Stp != nil {
		// no validation rules for Stp
	}

	if m.Network != nil {
		// no validation rules for Network
	}

	if m.Proto != nil {
		// no validation rules for Proto
	}

	if m.Device != nil {
		// no validation rules for Device
	}

	if m.ForceLink != nil {
		// no validation rules for ForceLink
	}

	if m.Metric != nil {
		// no validation rules for Metric
	}

	if m.Ip4Table != nil {
		// no validation rules for Ip4Table
	}

	if m.Ip6Table != nil {
		// no validation rules for Ip6Table
	}

	if m.Delegate != nil {
		// no validation rules for Delegate
	}

	if m.Ipv6 != nil {
		// no validation rules for Ipv6
	}

	if m.Ip6Assign != nil {
		// no validation rules for Ip6Assign
	}

	if m.Ip6Gateway != nil {
		// no validation rules for Ip6Gateway
	}

	if m.Ip6Hint != nil {
		// no validation rules for Ip6Hint
	}

	if m.Ip6Ifaceid != nil {
		// no validation rules for Ip6Ifaceid
	}

	if m.Ip6Deprecated != nil {
		// no validation rules for Ip6Deprecated
	}

	if m.SourceFilter != nil {
		// no validation rules for SourceFilter
	}

	if m.DnsMetric != nil {
		// no validation rules for DnsMetric
	}

	if m.PeerDns != nil {
		// no validation rules for PeerDns
	}

	if m.DhcpHostname != nil {
		// no validation rules for DhcpHostname
	}

	if m.DhcpClientId != nil {
		// no validation rules for DhcpClientId
	}

	if m.DhcpVendorId != nil {
		// no validation rules for DhcpVendorId
	}

	if m.DefaultRoute != nil {
		// no validation rules for DefaultRoute
	}

	if m.Broadcast != nil {
		// no validation rules for Broadcast
	}

	if m.FirewallZone != nil {
		// no validation rules for FirewallZone
	}

	if m.Bridge != nil {

		if all {
			switch v := interface{}(m.GetBridge()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Bridge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Bridge",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBridge()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Bridge",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Tunnel != nil {

		if all {
			switch v := interface{}(m.GetTunnel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Tunnel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Tunnel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Wireguard != nil {

		if all {
			switch v := interface{}(m.GetWireguard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Wireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Wireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWireguard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Wireguard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Mobile != nil {

		if all {
			switch v := interface{}(m.GetMobile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMobile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Mobile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.VirtualSettings != nil {

		if all {
			switch v := interface{}(m.GetVirtualSettings()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "VirtualSettings",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "VirtualSettings",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVirtualSettings()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "VirtualSettings",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Ppp != nil {

		if all {
			switch v := interface{}(m.GetPpp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Ppp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InterfaceValidationError{
						field:  "Ppp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPpp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InterfaceValidationError{
					field:  "Ppp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NoHostRoute != nil {
		// no validation rules for NoHostRoute
	}

	if m.Fwmark != nil {
		// no validation rules for Fwmark
	}

	if len(errors) > 0 {
		return InterfaceMultiError(errors)
	}

	return nil
}

// InterfaceMultiError is an error wrapping multiple validation errors returned
// by Interface.ValidateAll() if the designated constraints aren't met.
type InterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfaceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfaceMultiError) AllErrors() []error { return m }

// InterfaceValidationError is the validation error returned by
// Interface.Validate if the designated constraints aren't met.
type InterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfaceValidationError) ErrorName() string { return "InterfaceValidationError" }

// Error satisfies the builtin error interface
func (e InterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfaceValidationError{}

var _Interface_Name_Pattern = regexp.MustCompile("^[^\\s]*$")

var _Interface_Mac_Pattern = regexp.MustCompile("^(([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})|)$")

// Validate checks the field values on WirelessSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WirelessSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WirelessSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WirelessSettingsMultiError, or nil if none found.
func (m *WirelessSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *WirelessSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRadio()) < 1 {
		err := WirelessSettingsValidationError{
			field:  "Radio",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMode()) < 1 {
		err := WirelessSettingsValidationError{
			field:  "Mode",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Ssid != nil {
		// no validation rules for Ssid
	}

	if m.Bssid != nil {
		// no validation rules for Bssid
	}

	if m.Encryption != nil {

		if all {
			switch v := interface{}(m.GetEncryption()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WirelessSettingsValidationError{
						field:  "Encryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WirelessSettingsValidationError{
						field:  "Encryption",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEncryption()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WirelessSettingsValidationError{
					field:  "Encryption",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AckDistance != nil {
		// no validation rules for AckDistance
	}

	if m.RtsThreshold != nil {
		// no validation rules for RtsThreshold
	}

	if m.FragThreshold != nil {
		// no validation rules for FragThreshold
	}

	if m.MeshId != nil {
		// no validation rules for MeshId
	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if m.Wds != nil {
		// no validation rules for Wds
	}

	if m.Wmm != nil {
		// no validation rules for Wmm
	}

	if m.Isolate != nil {
		// no validation rules for Isolate
	}

	if m.Ieee80211R != nil {
		// no validation rules for Ieee80211R
	}

	if m.ReassociationDeadline != nil {
		// no validation rules for ReassociationDeadline
	}

	if m.FtPskGenerateLocal != nil {
		// no validation rules for FtPskGenerateLocal
	}

	if m.FtOverDs != nil {
		// no validation rules for FtOverDs
	}

	if m.RsnPreauth != nil {
		// no validation rules for RsnPreauth
	}

	if m.Macfilter != nil {
		// no validation rules for Macfilter
	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if m.Ifname != nil {
		// no validation rules for Ifname
	}

	if m.MaxAssociations != nil {
		// no validation rules for MaxAssociations
	}

	if m.MacaddrOverride != nil {
		// no validation rules for MacaddrOverride
	}

	if m.WpaVersion != nil {
		// no validation rules for WpaVersion
	}

	if m.WpaCipher != nil {
		// no validation rules for WpaCipher
	}

	if m.Wpa2Cipher != nil {
		// no validation rules for Wpa2Cipher
	}

	if m.WpaGroupRekeySeconds != nil {
		// no validation rules for WpaGroupRekeySeconds
	}

	if m.WpaPairwiseRekeySeconds != nil {
		// no validation rules for WpaPairwiseRekeySeconds
	}

	if m.WpaGmkRekeySeconds != nil {
		// no validation rules for WpaGmkRekeySeconds
	}

	if m.WpaPskFile != nil {
		// no validation rules for WpaPskFile
	}

	if m.DisableEapolKeyRetries != nil {
		// no validation rules for DisableEapolKeyRetries
	}

	if m.AuthServer != nil {
		// no validation rules for AuthServer
	}

	if m.AuthPort != nil {

		if m.GetAuthPort() != 0 {

			if m.GetAuthPort() > 65535 {
				err := WirelessSettingsValidationError{
					field:  "AuthPort",
					reason: "value must be less than or equal to 65535",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.AuthSecret != nil {
		// no validation rules for AuthSecret
	}

	if m.AcctServer != nil {
		// no validation rules for AcctServer
	}

	if m.AcctPort != nil {

		if m.GetAcctPort() != 0 {

			if m.GetAcctPort() > 65535 {
				err := WirelessSettingsValidationError{
					field:  "AcctPort",
					reason: "value must be less than or equal to 65535",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.AcctSecret != nil {
		// no validation rules for AcctSecret
	}

	if m.NasIdentifier != nil {
		// no validation rules for NasIdentifier
	}

	if m.OwnIpAddress != nil {
		// no validation rules for OwnIpAddress
	}

	if m.DynamicVlan != nil {
		// no validation rules for DynamicVlan
	}

	if m.WpsPushbutton != nil {
		// no validation rules for WpsPushbutton
	}

	if m.WpsLabel != nil {
		// no validation rules for WpsLabel
	}

	if m.WpsPin != nil {
		// no validation rules for WpsPin
	}

	if m.WpsConfig != nil {
		// no validation rules for WpsConfig
	}

	if m.WpsDeviceType != nil {
		// no validation rules for WpsDeviceType
	}

	if m.WpsDeviceName != nil {
		// no validation rules for WpsDeviceName
	}

	if m.WpsManufacturer != nil {
		// no validation rules for WpsManufacturer
	}

	if m.Ieee80211K != nil {
		// no validation rules for Ieee80211K
	}

	if m.RrmNeighborReport != nil {
		// no validation rules for RrmNeighborReport
	}

	if m.RrmBeaconReport != nil {
		// no validation rules for RrmBeaconReport
	}

	if m.Ieee80211V != nil {
		// no validation rules for Ieee80211V
	}

	if m.BssTransition != nil {
		// no validation rules for BssTransition
	}

	if m.WnmSleepMode != nil {
		// no validation rules for WnmSleepMode
	}

	if m.TimeAdvertisement != nil {
		// no validation rules for TimeAdvertisement
	}

	if m.R1KeyHolder != nil {
		// no validation rules for R1KeyHolder
	}

	if m.PmkR1Push != nil {
		// no validation rules for PmkR1Push
	}

	if m.R0KeyLifetime != nil {
		// no validation rules for R0KeyLifetime
	}

	if m.MaxListenInterval != nil {
		// no validation rules for MaxListenInterval
	}

	if m.DtimPeriod != nil {
		// no validation rules for DtimPeriod
	}

	if m.BeaconInterval != nil {
		// no validation rules for BeaconInterval
	}

	if m.ListenInterval != nil {
		// no validation rules for ListenInterval
	}

	if m.MaxInactivitySeconds != nil {
		// no validation rules for MaxInactivitySeconds
	}

	if m.SkipInactivityPoll != nil {
		// no validation rules for SkipInactivityPoll
	}

	if m.DisassocLowAck != nil {
		// no validation rules for DisassocLowAck
	}

	if m.MulticastRate != nil {
		// no validation rules for MulticastRate
	}

	if m.BroadcastSsid != nil {
		// no validation rules for BroadcastSsid
	}

	if m.MulticastToUnicast != nil {
		// no validation rules for MulticastToUnicast
	}

	if m.Doth != nil {
		// no validation rules for Doth
	}

	if m.ShortPreamble != nil {
		// no validation rules for ShortPreamble
	}

	if m.StartDisabled != nil {
		// no validation rules for StartDisabled
	}

	if m.OweTransitionSsid != nil {
		// no validation rules for OweTransitionSsid
	}

	if m.OweTransitionBssid != nil {
		// no validation rules for OweTransitionBssid
	}

	if m.EapType != nil {
		// no validation rules for EapType
	}

	if m.AuthMethod != nil {
		// no validation rules for AuthMethod
	}

	if m.Identity != nil {
		// no validation rules for Identity
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if m.CaCert != nil {
		// no validation rules for CaCert
	}

	if m.ClientCert != nil {
		// no validation rules for ClientCert
	}

	if m.PrivateKey != nil {
		// no validation rules for PrivateKey
	}

	if m.PrivateKeyPassword != nil {
		// no validation rules for PrivateKeyPassword
	}

	if m.TdlsProhibit != nil {
		// no validation rules for TdlsProhibit
	}

	if m.IappInterface != nil {
		// no validation rules for IappInterface
	}

	if len(errors) > 0 {
		return WirelessSettingsMultiError(errors)
	}

	return nil
}

// WirelessSettingsMultiError is an error wrapping multiple validation errors
// returned by WirelessSettings.ValidateAll() if the designated constraints
// aren't met.
type WirelessSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WirelessSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WirelessSettingsMultiError) AllErrors() []error { return m }

// WirelessSettingsValidationError is the validation error returned by
// WirelessSettings.Validate if the designated constraints aren't met.
type WirelessSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WirelessSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WirelessSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WirelessSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WirelessSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WirelessSettingsValidationError) ErrorName() string { return "WirelessSettingsValidationError" }

// Error satisfies the builtin error interface
func (e WirelessSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWirelessSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WirelessSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WirelessSettingsValidationError{}

// Validate checks the field values on WirelessEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WirelessEncryption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WirelessEncryption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WirelessEncryptionMultiError, or nil if none found.
func (m *WirelessEncryption) ValidateAll() error {
	return m.validate(true)
}

func (m *WirelessEncryption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Protocol != nil {
		// no validation rules for Protocol
	}

	if m.Cipher != nil {
		// no validation rules for Cipher
	}

	if m.Key != nil {
		// no validation rules for Key
	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if m.Ieee80211W != nil {
		// no validation rules for Ieee80211W
	}

	if m.Server != nil {
		// no validation rules for Server
	}

	if m.Port != nil {

		if m.GetPort() != 0 {

			if m.GetPort() > 65535 {
				err := WirelessEncryptionValidationError{
					field:  "Port",
					reason: "value must be less than or equal to 65535",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.AcctServer != nil {
		// no validation rules for AcctServer
	}

	if m.AcctServerPort != nil {

		if m.GetAcctServerPort() != 0 {

			if m.GetAcctServerPort() > 65535 {
				err := WirelessEncryptionValidationError{
					field:  "AcctServerPort",
					reason: "value must be less than or equal to 65535",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.WepKeyIndex != nil {
		// no validation rules for WepKeyIndex
	}

	if m.Ieee80211WMaxTimeout != nil {
		// no validation rules for Ieee80211WMaxTimeout
	}

	if m.Ieee80211WRetryTimeout != nil {
		// no validation rules for Ieee80211WRetryTimeout
	}

	if len(errors) > 0 {
		return WirelessEncryptionMultiError(errors)
	}

	return nil
}

// WirelessEncryptionMultiError is an error wrapping multiple validation errors
// returned by WirelessEncryption.ValidateAll() if the designated constraints
// aren't met.
type WirelessEncryptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WirelessEncryptionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WirelessEncryptionMultiError) AllErrors() []error { return m }

// WirelessEncryptionValidationError is the validation error returned by
// WirelessEncryption.Validate if the designated constraints aren't met.
type WirelessEncryptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WirelessEncryptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WirelessEncryptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WirelessEncryptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WirelessEncryptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WirelessEncryptionValidationError) ErrorName() string {
	return "WirelessEncryptionValidationError"
}

// Error satisfies the builtin error interface
func (e WirelessEncryptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWirelessEncryption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WirelessEncryptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WirelessEncryptionValidationError{}

// Validate checks the field values on InterfaceAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InterfaceAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InterfaceAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InterfaceAddressMultiError, or nil if none found.
func (m *InterfaceAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *InterfaceAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Address != nil {
		// no validation rules for Address
	}

	if m.Mask != nil {
		// no validation rules for Mask
	}

	if m.Gateway != nil {
		// no validation rules for Gateway
	}

	if m.Proto != nil {
		// no validation rules for Proto
	}

	if m.Family != nil {
		// no validation rules for Family
	}

	if len(errors) > 0 {
		return InterfaceAddressMultiError(errors)
	}

	return nil
}

// InterfaceAddressMultiError is an error wrapping multiple validation errors
// returned by InterfaceAddress.ValidateAll() if the designated constraints
// aren't met.
type InterfaceAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfaceAddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfaceAddressMultiError) AllErrors() []error { return m }

// InterfaceAddressValidationError is the validation error returned by
// InterfaceAddress.Validate if the designated constraints aren't met.
type InterfaceAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfaceAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfaceAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfaceAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfaceAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfaceAddressValidationError) ErrorName() string { return "InterfaceAddressValidationError" }

// Error satisfies the builtin error interface
func (e InterfaceAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterfaceAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfaceAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfaceAddressValidationError{}

// Validate checks the field values on BridgeSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BridgeSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BridgeSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BridgeSettingsMultiError,
// or nil if none found.
func (m *BridgeSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *BridgeSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ForwardDelay != nil {
		// no validation rules for ForwardDelay
	}

	if m.HelloTime != nil {
		// no validation rules for HelloTime
	}

	if m.Priority != nil {
		// no validation rules for Priority
	}

	if m.AgeingTime != nil {
		// no validation rules for AgeingTime
	}

	if m.MulticastQuerier != nil {
		// no validation rules for MulticastQuerier
	}

	if m.MaxAge != nil {
		// no validation rules for MaxAge
	}

	if m.QueryInterval != nil {
		// no validation rules for QueryInterval
	}

	if m.QueryResponseInterval != nil {
		// no validation rules for QueryResponseInterval
	}

	if m.LastMemberInterval != nil {
		// no validation rules for LastMemberInterval
	}

	if m.HashMax != nil {
		// no validation rules for HashMax
	}

	if m.Robustness != nil {
		// no validation rules for Robustness
	}

	if len(errors) > 0 {
		return BridgeSettingsMultiError(errors)
	}

	return nil
}

// BridgeSettingsMultiError is an error wrapping multiple validation errors
// returned by BridgeSettings.ValidateAll() if the designated constraints
// aren't met.
type BridgeSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BridgeSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BridgeSettingsMultiError) AllErrors() []error { return m }

// BridgeSettingsValidationError is the validation error returned by
// BridgeSettings.Validate if the designated constraints aren't met.
type BridgeSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BridgeSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BridgeSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BridgeSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BridgeSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BridgeSettingsValidationError) ErrorName() string { return "BridgeSettingsValidationError" }

// Error satisfies the builtin error interface
func (e BridgeSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBridgeSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BridgeSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BridgeSettingsValidationError{}

// Validate checks the field values on VlanFiltering with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VlanFiltering) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VlanFiltering with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VlanFilteringMultiError, or
// nil if none found.
func (m *VlanFiltering) ValidateAll() error {
	return m.validate(true)
}

func (m *VlanFiltering) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetVlan(); val < 1 || val > 4094 {
		err := VlanFilteringValidationError{
			field:  "Vlan",
			reason: "value must be inside range [1, 4094]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPorts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VlanFilteringValidationError{
						field:  fmt.Sprintf("Ports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VlanFilteringValidationError{
						field:  fmt.Sprintf("Ports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VlanFilteringValidationError{
					field:  fmt.Sprintf("Ports[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VlanFilteringMultiError(errors)
	}

	return nil
}

// VlanFilteringMultiError is an error wrapping multiple validation errors
// returned by VlanFiltering.ValidateAll() if the designated constraints
// aren't met.
type VlanFilteringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VlanFilteringMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VlanFilteringMultiError) AllErrors() []error { return m }

// VlanFilteringValidationError is the validation error returned by
// VlanFiltering.Validate if the designated constraints aren't met.
type VlanFilteringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VlanFilteringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VlanFilteringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VlanFilteringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VlanFilteringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VlanFilteringValidationError) ErrorName() string { return "VlanFilteringValidationError" }

// Error satisfies the builtin error interface
func (e VlanFilteringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVlanFiltering.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VlanFilteringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VlanFilteringValidationError{}

// Validate checks the field values on VlanPort with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VlanPort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VlanPort with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VlanPortMultiError, or nil
// if none found.
func (m *VlanPort) ValidateAll() error {
	return m.validate(true)
}

func (m *VlanPort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIfname()) < 1 {
		err := VlanPortValidationError{
			field:  "Ifname",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _VlanPort_Tagging_InLookup[m.GetTagging()]; !ok {
		err := VlanPortValidationError{
			field:  "Tagging",
			reason: "value must be in list [t u]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.PrimaryVid != nil {
		// no validation rules for PrimaryVid
	}

	if len(errors) > 0 {
		return VlanPortMultiError(errors)
	}

	return nil
}

// VlanPortMultiError is an error wrapping multiple validation errors returned
// by VlanPort.ValidateAll() if the designated constraints aren't met.
type VlanPortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VlanPortMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VlanPortMultiError) AllErrors() []error { return m }

// VlanPortValidationError is the validation error returned by
// VlanPort.Validate if the designated constraints aren't met.
type VlanPortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VlanPortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VlanPortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VlanPortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VlanPortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VlanPortValidationError) ErrorName() string { return "VlanPortValidationError" }

// Error satisfies the builtin error interface
func (e VlanPortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVlanPort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VlanPortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VlanPortValidationError{}

var _VlanPort_Tagging_InLookup = map[string]struct{}{
	"t": {},
	"u": {},
}

// Validate checks the field values on TunnelSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TunnelSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TunnelSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TunnelSettingsMultiError,
// or nil if none found.
func (m *TunnelSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *TunnelSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PeerAddr != nil {
		// no validation rules for PeerAddr
	}

	if m.IpAddr != nil {
		// no validation rules for IpAddr
	}

	if m.Ip6Addr != nil {
		// no validation rules for Ip6Addr
	}

	if m.Ip6Prefix != nil {
		// no validation rules for Ip6Prefix
	}

	if m.Tunlink != nil {
		// no validation rules for Tunlink
	}

	if m.TunnelDefaultRoute != nil {
		// no validation rules for TunnelDefaultRoute
	}

	if m.Ttl != nil {
		// no validation rules for Ttl
	}

	if m.Tos != nil {
		// no validation rules for Tos
	}

	if m.Ip6PrefixLen != nil {
		// no validation rules for Ip6PrefixLen
	}

	if m.Ip4PrefixLen != nil {
		// no validation rules for Ip4PrefixLen
	}

	if m.TunnelId != nil {
		// no validation rules for TunnelId
	}

	if m.Username != nil {
		// no validation rules for Username
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if m.UpdateKey != nil {
		// no validation rules for UpdateKey
	}

	if m.Server != nil {
		// no validation rules for Server
	}

	if m.CheckupInterval != nil {
		// no validation rules for CheckupInterval
	}

	if m.PppdOptions != nil {
		// no validation rules for PppdOptions
	}

	if len(errors) > 0 {
		return TunnelSettingsMultiError(errors)
	}

	return nil
}

// TunnelSettingsMultiError is an error wrapping multiple validation errors
// returned by TunnelSettings.ValidateAll() if the designated constraints
// aren't met.
type TunnelSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TunnelSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TunnelSettingsMultiError) AllErrors() []error { return m }

// TunnelSettingsValidationError is the validation error returned by
// TunnelSettings.Validate if the designated constraints aren't met.
type TunnelSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TunnelSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TunnelSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TunnelSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TunnelSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TunnelSettingsValidationError) ErrorName() string { return "TunnelSettingsValidationError" }

// Error satisfies the builtin error interface
func (e TunnelSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTunnelSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TunnelSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TunnelSettingsValidationError{}

// Validate checks the field values on WireguardInterfaceSettings with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WireguardInterfaceSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WireguardInterfaceSettings with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WireguardInterfaceSettingsMultiError, or nil if none found.
func (m *WireguardInterfaceSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *WireguardInterfaceSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PrivateKey != nil {
		// no validation rules for PrivateKey
	}

	if m.PublicKey != nil {
		// no validation rules for PublicKey
	}

	if m.ListenPort != nil {
		// no validation rules for ListenPort
	}

	if m.PresharedKey != nil {
		// no validation rules for PresharedKey
	}

	if m.Endpoint != nil {
		// no validation rules for Endpoint
	}

	if m.PersistentKeepalive != nil {
		// no validation rules for PersistentKeepalive
	}

	if len(errors) > 0 {
		return WireguardInterfaceSettingsMultiError(errors)
	}

	return nil
}

// WireguardInterfaceSettingsMultiError is an error wrapping multiple
// validation errors returned by WireguardInterfaceSettings.ValidateAll() if
// the designated constraints aren't met.
type WireguardInterfaceSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WireguardInterfaceSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WireguardInterfaceSettingsMultiError) AllErrors() []error { return m }

// WireguardInterfaceSettingsValidationError is the validation error returned
// by WireguardInterfaceSettings.Validate if the designated constraints aren't met.
type WireguardInterfaceSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WireguardInterfaceSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WireguardInterfaceSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WireguardInterfaceSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WireguardInterfaceSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WireguardInterfaceSettingsValidationError) ErrorName() string {
	return "WireguardInterfaceSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e WireguardInterfaceSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWireguardInterfaceSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WireguardInterfaceSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WireguardInterfaceSettingsValidationError{}

// Validate checks the field values on MobileSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MobileSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MobileSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MobileSettingsMultiError,
// or nil if none found.
func (m *MobileSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *MobileSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Device != nil {
		// no validation rules for Device
	}

	if m.Apn != nil {
		// no validation rules for Apn
	}

	if m.PinCode != nil {
		// no validation rules for PinCode
	}

	if m.Username != nil {
		// no validation rules for Username
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if m.Auth != nil {
		// no validation rules for Auth
	}

	if m.Mode != nil {
		// no validation rules for Mode
	}

	if m.PlmnId != nil {
		// no validation rules for PlmnId
	}

	if m.PdpType != nil {
		// no validation rules for PdpType
	}

	if m.Profile != nil {
		// no validation rules for Profile
	}

	if m.Service != nil {
		// no validation rules for Service
	}

	if m.InitString != nil {
		// no validation rules for InitString
	}

	if m.DelaySeconds != nil {
		// no validation rules for DelaySeconds
	}

	if len(errors) > 0 {
		return MobileSettingsMultiError(errors)
	}

	return nil
}

// MobileSettingsMultiError is an error wrapping multiple validation errors
// returned by MobileSettings.ValidateAll() if the designated constraints
// aren't met.
type MobileSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MobileSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MobileSettingsMultiError) AllErrors() []error { return m }

// MobileSettingsValidationError is the validation error returned by
// MobileSettings.Validate if the designated constraints aren't met.
type MobileSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MobileSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MobileSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MobileSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MobileSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MobileSettingsValidationError) ErrorName() string { return "MobileSettingsValidationError" }

// Error satisfies the builtin error interface
func (e MobileSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMobileSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MobileSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MobileSettingsValidationError{}

// Validate checks the field values on VirtualSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VirtualSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VirtualSettingsMultiError, or nil if none found.
func (m *VirtualSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Remote != nil {
		// no validation rules for Remote
	}

	if m.Local != nil {
		// no validation rules for Local
	}

	if m.Key != nil {
		// no validation rules for Key
	}

	if m.InputChecksum != nil {
		// no validation rules for InputChecksum
	}

	if m.OutputChecksum != nil {
		// no validation rules for OutputChecksum
	}

	if m.InputKey != nil {
		// no validation rules for InputKey
	}

	if m.OutputKey != nil {
		// no validation rules for OutputKey
	}

	if m.Vni != nil {
		// no validation rules for Vni
	}

	if m.Port != nil {
		// no validation rules for Port
	}

	if m.Group != nil {
		// no validation rules for Group
	}

	if m.InputInterface != nil {
		// no validation rules for InputInterface
	}

	if m.OutputInterface != nil {
		// no validation rules for OutputInterface
	}

	if m.TunnelSource != nil {
		// no validation rules for TunnelSource
	}

	if m.TunnelDestination != nil {
		// no validation rules for TunnelDestination
	}

	if len(errors) > 0 {
		return VirtualSettingsMultiError(errors)
	}

	return nil
}

// VirtualSettingsMultiError is an error wrapping multiple validation errors
// returned by VirtualSettings.ValidateAll() if the designated constraints
// aren't met.
type VirtualSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualSettingsMultiError) AllErrors() []error { return m }

// VirtualSettingsValidationError is the validation error returned by
// VirtualSettings.Validate if the designated constraints aren't met.
type VirtualSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualSettingsValidationError) ErrorName() string { return "VirtualSettingsValidationError" }

// Error satisfies the builtin error interface
func (e VirtualSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualSettingsValidationError{}

// Validate checks the field values on PppSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PppSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PppSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PppSettingsMultiError, or
// nil if none found.
func (m *PppSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *PppSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Username != nil {
		// no validation rules for Username
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if m.Service != nil {
		// no validation rules for Service
	}

	if m.Server != nil {
		// no validation rules for Server
	}

	if m.KeepaliveSeconds != nil {
		// no validation rules for KeepaliveSeconds
	}

	if m.Demand != nil {
		// no validation rules for Demand
	}

	if m.IdleTimeSeconds != nil {
		// no validation rules for IdleTimeSeconds
	}

	if len(errors) > 0 {
		return PppSettingsMultiError(errors)
	}

	return nil
}

// PppSettingsMultiError is an error wrapping multiple validation errors
// returned by PppSettings.ValidateAll() if the designated constraints aren't met.
type PppSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PppSettingsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PppSettingsMultiError) AllErrors() []error { return m }

// PppSettingsValidationError is the validation error returned by
// PppSettings.Validate if the designated constraints aren't met.
type PppSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PppSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PppSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PppSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PppSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PppSettingsValidationError) ErrorName() string { return "PppSettingsValidationError" }

// Error satisfies the builtin error interface
func (e PppSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPppSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PppSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PppSettingsValidationError{}

// Validate checks the field values on StaticRoute with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StaticRoute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StaticRoute with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StaticRouteMultiError, or
// nil if none found.
func (m *StaticRoute) ValidateAll() error {
	return m.validate(true)
}

func (m *StaticRoute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDevice()) < 1 {
		err := StaticRouteValidationError{
			field:  "Device",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestination()) < 1 {
		err := StaticRouteValidationError{
			field:  "Destination",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNext()) < 1 {
		err := StaticRouteValidationError{
			field:  "Next",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Cost != nil {
		// no validation rules for Cost
	}

	if m.Source != nil {
		// no validation rules for Source
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Table != nil {
		// no validation rules for Table
	}

	if m.Onlink != nil {
		// no validation rules for Onlink
	}

	if m.Mtu != nil {
		// no validation rules for Mtu
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if len(errors) > 0 {
		return StaticRouteMultiError(errors)
	}

	return nil
}

// StaticRouteMultiError is an error wrapping multiple validation errors
// returned by StaticRoute.ValidateAll() if the designated constraints aren't met.
type StaticRouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StaticRouteMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StaticRouteMultiError) AllErrors() []error { return m }

// StaticRouteValidationError is the validation error returned by
// StaticRoute.Validate if the designated constraints aren't met.
type StaticRouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StaticRouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StaticRouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StaticRouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StaticRouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StaticRouteValidationError) ErrorName() string { return "StaticRouteValidationError" }

// Error satisfies the builtin error interface
func (e StaticRouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStaticRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StaticRouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StaticRouteValidationError{}

// Validate checks the field values on Radio with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Radio) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Radio with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RadioMultiError, or nil if none found.
func (m *Radio) ValidateAll() error {
	return m.validate(true)
}

func (m *Radio) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := RadioValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProtocol()) < 1 {
		err := RadioValidationError{
			field:  "Protocol",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Phy != nil {
		// no validation rules for Phy
	}

	if m.Country != nil {
		// no validation rules for Country
	}

	if m.Channel != nil {

		if m.GetChannel() > 177 {
			err := RadioValidationError{
				field:  "Channel",
				reason: "value must be less than or equal to 177",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.TxPower != nil {
		// no validation rules for TxPower
	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if m.DriverType != nil {
		// no validation rules for DriverType
	}

	if m.Band != nil {
		// no validation rules for Band
	}

	if m.Hwmode != nil {
		// no validation rules for Hwmode
	}

	if m.Htmode != nil {
		// no validation rules for Htmode
	}

	if m.Chanbw != nil {
		// no validation rules for Chanbw
	}

	if m.TxAntenna != nil {
		// no validation rules for TxAntenna
	}

	if m.RxAntenna != nil {
		// no validation rules for RxAntenna
	}

	if m.Antenna != nil {
		// no validation rules for Antenna
	}

	if m.Diversity != nil {
		// no validation rules for Diversity
	}

	if m.Distance != nil {
		// no validation rules for Distance
	}

	if m.FragThreshold != nil {
		// no validation rules for FragThreshold
	}

	if m.RtsThreshold != nil {
		// no validation rules for RtsThreshold
	}

	if m.BeaconInterval != nil {
		// no validation rules for BeaconInterval
	}

	if m.BasicRate != nil {
		// no validation rules for BasicRate
	}

	if m.SupportedRates != nil {
		// no validation rules for SupportedRates
	}

	if m.RequireMode != nil {
		// no validation rules for RequireMode
	}

	if m.LegacyRates != nil {
		// no validation rules for LegacyRates
	}

	if m.Noscan != nil {
		// no validation rules for Noscan
	}

	if m.LogLevel != nil {
		// no validation rules for LogLevel
	}

	if m.ShortGi != nil {
		// no validation rules for ShortGi
	}

	if m.Greenfield != nil {
		// no validation rules for Greenfield
	}

	if m.Txqueuelen != nil {
		// no validation rules for Txqueuelen
	}

	if m.Dfs != nil {
		// no validation rules for Dfs
	}

	if m.CountryIe != nil {
		// no validation rules for CountryIe
	}

	if m.CellDensity != nil {
		// no validation rules for CellDensity
	}

	if len(errors) > 0 {
		return RadioMultiError(errors)
	}

	return nil
}

// RadioMultiError is an error wrapping multiple validation errors returned by
// Radio.ValidateAll() if the designated constraints aren't met.
type RadioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RadioMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RadioMultiError) AllErrors() []error { return m }

// RadioValidationError is the validation error returned by Radio.Validate if
// the designated constraints aren't met.
type RadioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RadioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RadioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RadioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RadioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RadioValidationError) ErrorName() string { return "RadioValidationError" }

// Error satisfies the builtin error interface
func (e RadioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRadio.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RadioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RadioValidationError{}
